# Control point Окулов Артемий ИТ-17
1 Постановка задачи:

В файле даны n целых чисел, и здесь же указан путь их размещения в бинарном
дереве виде двоичного кода (коды не повторяются). Построить двоичное
дерево целых чисел, в котором путь по дереву определяется указанным
двоичным кодом в этом листе (1 – переход к правому потомку, 0 - переход к
левому потомку). В корень автоматически заносится значение 0.
Учитывать ситуацию, когда дерево не может быть построено.

2 Алгоритм решения:

Проект состоит из трех файлов:
main.cpp — точка входа, чтение файла, построение дерева и его вывод.
binary_tree.h — заголовочный файл с объявлением структуры Node и функций.
binary_tree.cpp — реализация всех функций для работы с деревом.

Основной модуль программы(main.cpp):
Открывает файл numbersAndBinaryCode.txt.
Поочередно считывает строки.
Разбирает каждую строку на значение и двоичный код.
Проверяет существование пути с помощью pathExists.
Добавляет узлы с помощью buildBinaryTree и insertNode.
Выводит результат при помощи printTree.

Структура Node
Представляет узел дерева:
struct Node {
int value;
Node* left;
Node* right;
Node(int val) : value(val), left(nullptr), right(nullptr) {}
};

Как работатет:
Хранит значение узла (value),
Указатели на левого и правого потомков (left, right),
Инициализируется значением 0.

Функция buildBinaryTree
Создает корень дерева (value = 0) и добавляет первый узел по указанному двоичному коду.
Вызывает insertNode() для построения пути.

Функция insertNode
Рекурсивно добавляет узлы по заданному двоичному коду:
Для каждого символа строки '0' или '1' переходит к соответствующему потомку.
Если потомка нет — создает новый узел со значением 0.
Доходит до конца пути и присваивает узлу переданное значение.

Функция pathExists
Проверяет, существует ли уже такой путь в дереве и был ли он использован для хранения значения: 
проходит по дереву по символам двоичного кода.
Если путь существует и значение узла не равно 0 возвращает true.

Функция printTree
Выводит дерево в консоль в виде боковой структуры с ветвями: 
использует рекурсию и выводит узлы начиная с правого потомка, чтобы дерево строилось вверх.
Использует префиксы "├──" и "└──" для отображения иерархии.
